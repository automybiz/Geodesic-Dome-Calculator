<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3V 5/8 Geodesic Dome Visualizer</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #111;
            --accent-a: #ff4444; /* Red */
            --accent-b: #4444ff; /* Blue */
            --accent-c: #ffcc00; /* Gold */
            --text-color: #eee;
            --border-color: #333;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            padding: 10px;
            text-align: center;
        }
        .header h2 { margin: 0 0 5px 0; }
        .header p { margin: 0; font-size: 0.9em; color: #aaa; }

        .main-container {
            display: flex;
            flex: 1;
            width: 100%;
            max-width: 1800px; /* Increased max width */
            gap: 15px;
            padding: 15px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrolling if possible */
        }

        .visualizer-area {
            flex: 4; /* Takes up much more space */
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .controls-area {
            flex: 1; /* Narrower */
            max-width: 300px; /* Fixed max width constraint */
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto; /* Allow scrolling if controls don't fit */
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: move;
        }

        .strut {
            stroke-width: 2;
            stroke-linecap: round;
            transition: opacity 0.3s;
        }

        .strut.A { stroke: var(--accent-a); }
        .strut.B { stroke: var(--accent-b); }
        .strut.C { stroke: var(--accent-c); }

        .strut.dimmed {
            opacity: 0.1;
        }

        h2, h3 { margin-top: 0; color: #0ff; }
        h3 { font-size: 1.1em; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .btn {
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            width: 100%;
            box-sizing: border-box;
        }

        .btn:hover {
            background: #333;
            border-color: #0ff;
        }

        .btn.active {
            background: #044;
            border-color: #0ff;
        }
        
        .btn.inactive {
            opacity: 0.5;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.9em;
        }

        input[type=range] {
            width: 100%;
            accent-color: #0ff;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: auto;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .swatch {
            width: 16px;
            height: 4px;
            border-radius: 2px;
        }

        .count-badge {
            margin-left: auto;
            background: #222;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            color: #0ff;
            border: 1px solid #333;
            min-width: 20px;
            text-align: center;
        }

        .back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            text-decoration: none;
            color: #0ff;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #333;
            transition: all 0.2s;
        }

        .back-btn:hover {
            border-color: #0ff;
            background: #003333;
            box-shadow: 0 0 10px rgba(0,255,255,0.2);
        }

        .dir-arrow {
            font-size: 1.2em;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="header">
        <h2>3V 5/8 Geodesic Dome Visualizer</h2>
        <p>Interactive breakdown of the 165 struts (30A, 55B, 80C)</p>
    </div>

    <div class="main-container">
        <div class="visualizer-area" id="vizContainer">
            <a href="index.html" class="back-btn">‚Üê Back to Calculator</a>
            <svg id="domeSvg" viewBox="-150 -150 300 300">
                <g id="strutGroup"></g>
            </svg>
        </div>

        <div class="controls-area">
            <h3>Controls</h3>
            
            <button class="btn" id="pauseBtn">
                <span id="pauseIcon">‚è∏</span> <span id="pauseText">Pause Rotation</span>
            </button>

            <button class="btn" id="dirBtn">
                <span>Toggle Direction</span>
                <span id="dirArrow" class="dir-arrow">‚Üí</span>
            </button>

            <div class="slider-group">
                <label>Rotation Speed</label>
                <input type="range" id="speedSlider" min="0" max="100" value="30">
            </div>

            <hr style="width:100%; border:0; border-top:1px solid #333; margin: 10px 0;">

            <h3>Filter Groups</h3>
            <button class="btn active" id="btnShowAll">Show All Struts (165)</button>
            <button class="btn active" id="btnToggleA">Show A (30)</button>
            <button class="btn active" id="btnToggleB">Show B (55)</button>
            <button class="btn active" id="btnToggleC">Show C (80)</button>

            <button class="btn" id="buildBtn" style="margin-top:10px; border-color: #fa0; color: #fa0;">
                üèó Replay Build Sequence
            </button>

            <div class="legend">
                <div class="legend-item">
                    <div class="swatch" style="background: var(--accent-a);"></div>
                    <span>Group A (Pentagons)</span>
                    <span class="count-badge" id="countA">0</span>
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background: var(--accent-b);"></div>
                    <span>Group B (Internal)</span>
                    <span class="count-badge" id="countB">0</span>
                </div>
                <div class="legend-item">
                    <div class="swatch" style="background: var(--accent-c);"></div>
                    <span>Group C (Base/Main)</span>
                    <span class="count-badge" id="countC">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const R = 120; // Visual radius

        // Settings State
        const settings = {
            angle: 0,
            isPaused: false,
            direction: 1, // 1 or -1
            speed: 30, // 0-100
            visible: { A: true, B: true, C: true }
        };

        // Load Saved Settings
        const saved = localStorage.getItem('domeVizSettings');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                settings.speed = parsed.speed ?? 30;
                settings.direction = parsed.direction ?? 1;
                settings.visible = parsed.visible ?? { A: true, B: true, C: true };
            } catch(e) {}
        }
        
        let currentAngle = 0; // Runtime angle

        const strutGroup = document.getElementById('strutGroup');
        const struts = []; 

        function createStrut(p1, p2, type) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.classList.add("strut", type);
            // Initial positioning (will be updated by loop)
            line.setAttribute("x1", p1[0]);
            line.setAttribute("y1", p1[1]);
            line.setAttribute("x2", p2[0]);
            line.setAttribute("y2", p2[1]);
            
            strutGroup.appendChild(line);
            struts.push({ el: line, p1, p2, type });
        }

        // Helper: 3D Distance
        function dist3D(a, b) {
            return Math.sqrt(
                Math.pow(a[0]-b[0], 2) + 
                Math.pow(a[1]-b[1], 2) + 
                Math.pow(a[2]-b[2], 2)
            );
        }

        /**
         * 3V 5/8 DOME GENERATOR (Corrected Kruschke Method / Class I)
         * This method constructs the dome tier-by-tier to ensure correct strut counts and flat base.
         * 
         * 3V 5/8 Dome Specs:
         * - 30 A Struts (Pentagon star)
         * - 55 B Struts (Hexagon/Pentagon connectors)
         * - 80 C Struts (Base ring + Hexagon perimeters)
         * - Total: 165 Struts
         */
        function generateDome() {
            // We use normalized coordinates on a unit sphere (R=1).
            // Key constants for 3V
            // To get a flat base, we must generate vertices at specific latitudes.
            // 3V Class 1 (Method 1) breakdown:
            // - Pole (1 point)
            // - Ring 1 (5 points)
            // - Ring 2 (10 points)
            // - Ring 3 (15 points) -> This is the 3/8ths line (approx)
            // - Ring 4 (20 points) -> ? No, let's use subdivision logic but filtered correctly.
            
            // Re-attempting Subdivision with strict Face Orientation
            // Top Vertex: (0, 1, 0)
            // 5 Top Vertices: Lat ~26.565 deg
            // 5 Bottom Vertices: Lat ~-26.565 deg
            // Bottom Vertex: (0, -1, 0)
            
            const PHI = (1 + Math.sqrt(5)) / 2;
            // Radius of the pentagon rings in unit icosahedron
            const R_RING = 2 / Math.sqrt(5); // ~0.8944
            const Y_RING = 1 / Math.sqrt(5); // ~0.4472

            // Base Vertices of aligned Icosahedron (Y is UP)
            const verts = [];
            verts.push([0, 1, 0]); // 0: Top Pole

            // 1-5: Top Ring
            for (let i = 0; i < 5; i++) {
                const theta = (i * 2 * Math.PI) / 5;
                verts.push([R_RING * Math.cos(theta), Y_RING, R_RING * Math.sin(theta)]);
            }
            
            // 6-10: Bottom Ring (offset by 36deg)
            for (let i = 0; i < 5; i++) {
                const theta = (i * 2 * Math.PI) / 5 + (Math.PI / 5);
                verts.push([R_RING * Math.cos(theta), -Y_RING, R_RING * Math.sin(theta)]);
            }
            
            verts.push([0, -1, 0]); // 11: Bottom Pole

            // Faces of Icosahedron
            const faces = [
                // Top Cap
                [0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1],
                // Mid Band Up-pointing
                [1, 6, 2], [2, 7, 3], [3, 8, 4], [4, 9, 5], [5, 10, 1],
                // Mid Band Down-pointing
                [6, 7, 2], [7, 8, 3], [8, 9, 4], [9, 10, 5], [10, 6, 1],
                // Bottom Cap (We don't need these for 5/8 dome but good for completeness)
                [6, 11, 7], [7, 11, 8], [8, 11, 9], [9, 11, 10], [10, 11, 6]
            ];

            const points = [];
            const pMap = {};
            const edges = new Set();

            function getP(p) {
                // Normalize to sphere
                const d = Math.sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2]);
                const n = [p[0]/d, p[1]/d, p[2]/d];
                
                // key for dedup
                const k = n.map(x => x.toFixed(5)).join(',');
                if (pMap[k] !== undefined) return pMap[k];
                const idx = points.length;
                points.push(n);
                pMap[k] = idx;
                return idx;
            }

            // Subdivide
            const freq = 3;
            
            // We only need to process faces that contribute to the top 5/8ths.
            // In 3V Class I:
            // Top 5 faces: Fully included
            // Middle 10 faces: Fully included? 
            // Let's subdivide ALL faces, then filter nodes by Latitude.
            
            faces.forEach(tri => {
                const A = verts[tri[0]];
                const B = verts[tri[1]];
                const C = verts[tri[2]];
                
                const grid = [];
                for(let r=0; r<=freq; r++) {
                    grid[r] = [];
                    for(let c=0; c<=freq-r; c++) {
                        const w = 1.0 - r/freq - c/freq;
                        const u = r/freq;
                        const v = c/freq;
                        
                        const p = [
                            w*A[0] + u*B[0] + v*C[0],
                            w*A[1] + u*B[1] + v*C[1],
                            w*A[2] + u*B[2] + v*C[2]
                        ];
                        grid[r][c] = getP(p);
                    }
                }
                
                // Add Edges
                for(let r=0; r<=freq; r++) {
                    for(let c=0; c<=freq-r; c++) {
                        const i = grid[r][c];
                        // Neighbors: (r+1, c), (r, c+1), (r+1, c-1)? 
                        // Standard barycentric grid neighbors:
                        if (r < freq && c < freq-r) { // Up/Right?
                            // This grid mapping direction depends on u,v,w mapping.
                            // Let's just connect known valid grid neighbors
                            
                            // Right neighbor (same row)
                            if (c+1 <= freq-r) addEdge(i, grid[r][c+1]);
                            
                            // "Up" neighbor (next row)
                            if (r+1 <= freq) {
                                if (c <= freq-(r+1)) addEdge(i, grid[r+1][c]);
                                // Diagonal
                                if (c > 0) addEdge(i, grid[r+1][c-1]);
                            }
                        }
                    }
                }
            });

            function addEdge(i1, i2) {
                if (i1 === i2) return;
                const k = i1 < i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                if (edges.has(k)) return;
                
                const p1 = points[i1];
                const p2 = points[i2];
                
                // 5/8 FILTER LOGIC
                // In a 3V Class I Dome (radius 1):
                // Row 0 (Top): Y = 1
                // ...
                // The Base Ring for 5/8 is roughly at Y = -0.1876 (derived from 3V geometry).
                // It is the ring formed by the subdivision lines passing through the lower pentagon centers.
                // We want to keep every edge that is ON or ABOVE this ring.
                
                // Use a generous epsilon because floats are imperfect.
                const CUTOFF_Y = -0.25; 
                
                if (p1[1] >= CUTOFF_Y && p2[1] >= CUTOFF_Y) {
                    edges.add(k);
                    
                    const d = dist3D(p1, p2);
                    
                    // Classification based on 3V Chord Factors
                    // A: 0.3486
                    // B: 0.4035
                    // C: 0.4124
                    let type = 'C';
                    if (d < 0.38) type = 'A';
                    else if (d < 0.408) type = 'B';
                    else type = 'C';
                    
                    createStrut(
                        p1.map(c => c * R),
                        p2.map(c => c * R),
                        type
                    );
                }
            }
        }

        function project(p) {
            // Y is Up in model.
            // Z is Depth.
            // X is Side.
            
            // Rotation around Y axis
            const rad = angle;
            const x = p[0]*Math.cos(rad) + p[2]*Math.sin(rad);
            const z = p[2]*Math.cos(rad) - p[0]*Math.sin(rad);
            const y = p[1];
            
            // Tilt for 3D effect (Rotate around X)
            // Looking down slightly
            const tilt = 0.2; 
            const y2 = y*Math.cos(tilt) - z*Math.sin(tilt);
            const z2 = y*Math.sin(tilt) + z*Math.cos(tilt);
            
            // SVG Projection
            // SVG Y is down, so we flip y2.
            // Move center to (0,0) is handled by viewBox.
            // We want the BASE of the dome (approx Y = -0.2*R) to be visually grounded.
            // y2 range: Top=~1*R, Bottom=~-0.2*R.
            // In SVG coords: Top=-R, Bottom=+0.2*R.
            // Let's shift it down a bit to center it.
            
            return [x, -y2 + 20, z2];
        }

        function saveSettings() {
            localStorage.setItem('domeVizSettings', JSON.stringify(settings));
        }

        function applyVisibility() {
            struts.forEach(s => {
                if (settings.visible[s.type]) {
                    s.el.classList.remove('dimmed');
                } else {
                    s.el.classList.add('dimmed');
                }
            });
            
            document.getElementById('btnToggleA').className = settings.visible.A ? 'btn active' : 'btn';
            document.getElementById('btnToggleB').className = settings.visible.B ? 'btn active' : 'btn';
            document.getElementById('btnToggleC').className = settings.visible.C ? 'btn active' : 'btn';
            
            const allOn = settings.visible.A && settings.visible.B && settings.visible.C;
            document.getElementById('btnShowAll').className = allOn ? 'btn active' : 'btn';
            
            saveSettings();
        }

        function update() {
            if (!settings.isPaused) {
                currentAngle += (settings.speed / 3000) * settings.direction;
            }
            angle = currentAngle;

            struts.forEach(s => {
                const proj1 = project(s.p1);
                const proj2 = project(s.p2);
                
                s.el.setAttribute("x1", proj1[0]);
                s.el.setAttribute("y1", proj1[1]);
                s.el.setAttribute("x2", proj2[0]);
                s.el.setAttribute("y2", proj2[1]);
                
                const depth = (proj1[2] + proj2[2]) / 2;
                let baseOpacity = ((depth + R) / (2*R)) * 0.7 + 0.3;
                if (baseOpacity < 0.1) baseOpacity = 0.1;
                if (baseOpacity > 1) baseOpacity = 1;

                if (s.el.classList.contains('dimmed')) {
                    s.el.style.opacity = 0; 
                } else {
                    s.el.style.opacity = baseOpacity;
                }
            });

            requestAnimationFrame(update);
        }

        // --- Controls ---
        document.getElementById('pauseBtn').onclick = () => {
            settings.isPaused = !settings.isPaused;
            document.getElementById('pauseIcon').innerText = settings.isPaused ? "‚ñ∂" : "‚è∏";
            document.getElementById('pauseText').innerText = settings.isPaused ? "Resume Rotation" : "Pause Rotation";
            document.getElementById('pauseBtn').classList.toggle('active', settings.isPaused);
            saveSettings();
        };

        document.getElementById('dirBtn').onclick = () => {
            settings.direction *= -1;
            document.getElementById('dirArrow').innerText = settings.direction > 0 ? "‚Üí" : "‚Üê";
            saveSettings();
        };

        const slider = document.getElementById('speedSlider');
        slider.value = settings.speed;
        slider.oninput = (e) => {
            settings.speed = parseInt(e.target.value);
            saveSettings();
        };

        document.getElementById('btnShowAll').onclick = () => {
            settings.visible.A = true;
            settings.visible.B = true;
            settings.visible.C = true;
            applyVisibility();
        };

        document.getElementById('btnToggleA').onclick = () => { settings.visible.A = !settings.visible.A; applyVisibility(); };
        document.getElementById('btnToggleB').onclick = () => { settings.visible.B = !settings.visible.B; applyVisibility(); };
        document.getElementById('btnToggleC').onclick = () => { settings.visible.C = !settings.visible.C; applyVisibility(); };

        document.getElementById('buildBtn').onclick = () => {
            struts.forEach(s => s.el.style.display = 'none');
            setTimeout(() => { struts.forEach(s => { if(s.type === 'A') s.el.style.display = 'block'; }); }, 100);
            setTimeout(() => { struts.forEach(s => { if(s.type === 'B') s.el.style.display = 'block'; }); }, 1100);
            setTimeout(() => { struts.forEach(s => { if(s.type === 'C') s.el.style.display = 'block'; }); }, 2100);
        };

        // Start
        generateDome();
        
        // Restore UI
        if (settings.isPaused) {
             document.getElementById('pauseIcon').innerText = "‚ñ∂";
             document.getElementById('pauseText').innerText = "Resume Rotation";
             document.getElementById('pauseBtn').classList.add('active');
        }
        document.getElementById('dirArrow').innerText = settings.direction > 0 ? "‚Üí" : "‚Üê";
        applyVisibility();
        
        // Counts
        const counts = struts.reduce((acc, s) => {
            acc[s.type] = (acc[s.type] || 0) + 1;
            return acc;
        }, {A:0, B:0, C:0});
        document.getElementById('countA').innerText = counts.A;
        document.getElementById('countB').innerText = counts.B;
        document.getElementById('countC').innerText = counts.C;

        update();
    </script>
</body>
</html>
